---
layout: docs-ja
title: 技術
category: Manual
permalink: /manuals/1.0/ja/tech.html
---
# 技術

BEAR.Sundayは依存性の注入（DI）、アスペクト指向プログラミング（AOP）、リソース指向のアーキテクチャ（ROA）などの技術を組み合わせて、柔軟で拡張性の高いアプリケーションを構築するためのフレームワークです。この章では、BEAR.Sundayの機能と特徴について詳しく説明します。

### 依存性の注入 (DI)

依存性の注入 (DI)はオブジェクトの生成や依存解決をフレームワークが自動で行い、コードの結合度を下げ、テスト性や保守性を高めるパターンです。BEAR.SundayのDIはRay.Diとして独立したパッケージを使っていてこれはGoogle社製のDIフレームワークであるGuiceの設計思想を取り入れ、ほぼ全ての機能をカバーしています。

他のフレームワークのDIとの違いは、設定時でもユーザーはコンテナに直接触ることなく、つまり実装によってではなくルールによって依存を解決するオートワイアリングが基本となっていることです。他の特徴は以下のとおり。 、

* コンテキストに応じた束縛で、アプリケーションの振る舞いを変更できます。
* DIのコンパイルを行いインスタンス生成のPHPコードを生成することで、実行時のオーバーヘッドを最小限に抑えます。
* オブジェクトの依存関係はグラフで可視化できます。
* インスタンスをルールに基づいて生成します。コンパイル（設定）時でさえユーザーはコンテナに直接アクセスすることはありません。

### アスペクト指向プログラミング (AOP)

アスペクト指向プログラミング (AOP)はビジネスロジックなど本質的関心とログやキャッシュや横断的関心を分離し、柔軟なアプリケーションを実現するパターンです。BEAR.SundayのAOPはRay.Aopとして独立したパッケージを使っていてこれはPHPのアトリビュートをクラスやメソッドに付与して、横断的処理を宣言的に束縛します。そのほかのAOPの特徴は以下のとおり。

* クラスやメソッド名など探索条件に適合したクラスやメソッドに横断的処理を束縛できます。
* PHPのアトリビュートをクラスやメソッドに付与して、横断的処理を宣言的に束縛します。
* クラスやメソッド名など探索条件に適合したクラスやメソッドに横断的処理を束縛できます。

### リソース指向のアーキテクチャ (ROA)

BEAR.SundayのROAはRESTfulなAPIをWebアプリケーション内部構造でも実現するためのアーキテクチャでBEAR.Sundayの設計原則の中核です。ハイパーメディアフレームワークであり、オブジェクト as a サービスでもあるといえます。Webと同じく、全てのデータや機能をリソースとして扱い、GET/POST/PUT/DELETEなど規定されたインターフェースで操作します。

#### リソース

リソースはアプリケーションの中心的な概念で、URIで表現されるユニークな識別子を持ちます。各リソースは状態を持ち、その状態はリソースの表現（representation）として提供されます。リソースの状態は不変であり、状態を変更するにはリソースに対して新しい表現を送信する必要があります。

#### ユニフォームインターフェース

リソースへのアクセスはHTTPのメソッド（GET, POST, PUT, DELETE）を用いて行われます。これらのメソッドはリソースに対して実行できる操作を規定しており、リソースの種類に関わらず共通のインターフェースを提供します。

- GET: リソースの現在の状態を取得する
- POST: リソースに対して冪等性のない操作を行う（作成など）
- PUT: リソースに対して冪等性のある操作を行う（作成または更新など）
- DELETE: リソースを削除する

#### ハイパーメディア

リソース間のリンクはハイパーメディアによって表現されます。各リソースの表現にはリンクが含まれ、クライアントはこれらのリンクをたどることでアプリケーション内を遷移できます。これによってクライアントとサーバー間の結合度が低くなり、アプリケーションの柔軟性が高まります。内部にリンクすることでコンテンツをツリー状に表すこともできます。

#### 値と表現の分離

BEAR.SundayのROAでは、リソースの値と表現が明確に分離されています。リソースの値はアプリケーションのドメインロジックによって管理され、表現はその値を様々な形式（JSON, XML, HTMLなど）で表現するためのものです。この分離によってドメインロジックとプレゼンテーションロジックが疎結合になり、アプリケーションの保守性と拡張性が向上します。

#### pageリソースとappリソース

BEAR.SundayのROAでは、リソースをpageリソースとappリソースに分類しています。

- pageリソース: 主にHTMLを表現とするリソースで、Webブラウザからアクセスされることを想定しています。ユーザーインターフェースを構成するリソースです。
- appリソース: アプリケーションのバックエンドを構成するリソースで、主にJSONやXMLを表現とします。他のアプリケーションやサービスからアクセスされることを想定しています。

pageリソースとappリソースを分離することで、ユーザーインターフェースとアプリケーションロジックを独立に開発・デプロイできます。また、appリソースを再利用することで、複数のユーザーインターフェース（Webブラウザ、モバイルアプリ、他のサービスなど）に対して一貫したバックエンドを提供できます。

BEAR.SundayのROAを用いることで、Webの設計原則に沿ったスケーラブルで疎結合なアプリケーションを構築できます。値と表現の分離によってドメインロジックとプレゼンテーションロジックを独立に開発・テストできるため、アプリケーションの品質と開発効率が向上します。またpageリソースとappリソースを分離することで、ユーザーインターフェースとアプリケーションロジックを独立に開発・デプロイでき、アプリケーションの柔軟性と拡張性が向上します。

## MVCとの相違点

BEAR.SundayのROAは、従来のMVCアーキテクチャとは異なるアプローチをとっています。

* MVCのコントローラーは複数の責任を持ちがちですが、BEAR.SundayのリソースはDIとAOPで単一責任の原則（SRP）に従い、責任が分散されています。
* MVCのコントローラーは様々な操作を行いますが、BEAR.Sundayのリソースはセマンティックなメソッド（意味的に明確なメソッド）を持ち、操作が明確になります。
* BEAR.Sundayでは埋め込みリソースを使い、コンテンツの依存関係が宣言的に示されます。これによりリソース間の関係性が明示的になるだけでなく、キャッシュ無効化のための依存解決も行えます。
* BEAR.Sundayはリソース自身が表現の責任を持ち、自己完結性が高まります。
* BEAR.Sundayのリソースはリレーションを宣言することで、可能な操作（アフォーダンス）を提供します。クライアントはこれを手がかりにリソースを動的に操作できます。
* リンクにはHAL（Hypertext Application Language）を採用し、リソース間のリンクを標準化します。
* 依存関係がURIで表されるので、リソースのツリー構造だけでなくキャッシュの依存解決も同時に行うことができます。
* MVCのコントローラーモデルと違って、コンソールを含む多様なクライアントから直接コールすることができ接続性が向上します。
* PageリソースとAppリソースはコントローラーとモデルと対比もできますが、モデルがコントローラーやPHP言語を超えたところから直接操作が困難なことに対して、AppリソースはPageリソースだけでなく多様なクライアントからのリクエストに答えることができます。
* HTMLサイトとAPIサイトを別々に構築する必要がなく、同じリソースを使ってHTMLサイトとAPIサイトを同時に構築できます。


### テストの容易性

* 各リソースは独立していて、RESTのステートレスリクエストの性質によりテストは容易です。
* リソースの状態と表現を分離し、リソースの状態を変更せずに表現のみをテスト可能です。
* ハイパーメディアのリンクをたどりながらAPIのテストを行え、PHPとHTTPの同一コードでテストできます。

### リソースの検証

JsonSchemaを使用してリソースの表現を検証し、リソースの整合性を保ちます。バリデーションに標準のスキーマを使うことで外部ツールの利用ができます。

### ストリーム出力
* リソースの表現をストリーム出力することで、メモリ上では扱えない大規模なコンテンツを出力できます。
* ストリームは通常の値のアサインと混在することができます。

### 視覚化とデバッグ

* 開発時にHTML上でリソースの範囲やツールをグラフィカルに表示します。
* Web画面でリソースの状態を確認でき、PHPコードやHTMLテンプレートをオンラインで編集し、リアルタイムに反映できます。

### 起動の高速化

* 事前コンパイルにより依存生成のPHPコードを生成して最小限のブートストラップを実現します。
* 理想的なDIの世界では起動の時に1度だけインスタンスを生成します。これをルートオブジェクトと呼びますがこのルートオブジェクトをキャッシュすることで、初期化を再利用しアプリケーションの起動を高速化します。

## PHPインターフェイスとSQL実行の統合
BEAR.Sundayでは、PHPのインターフェイスを使って、データベースとのやり取りを行うSQL文の実行を簡単に管理できます。クラスを実装することなく、インターフェイスに直接SQLの実行オブジェクトを束縛することが可能です。これにより、コードの再利用性が向上し、モジュール性が強化されます。

### クエリー引数の評価
BEAR.Sundayのインターフェイスは、単なるスカラー値だけでなくオブジェクトも受け入れることができます。特に、オブジェクトがインターフェイスによってどのように評価されるかは重要です。例えば、DateTimeInterface オブジェクトをインターフェイスに渡すと、これがSQL文内で適切に日付として扱われるように自動的に評価されます。これにより、日付や時刻のデータを効率的に扱うことができます。

### クエリーの引数の依存性注入
BEAR.Sundayでは、インターフェイスに対して依存性を注入することも可能です。これにより、必要なオブジェクトや値を動的にインターフェイスに供給することができ、より柔軟なアプリケーション設計が実現されます。依存性注入を用いることで、コードのテストが容易になり、結合度を低く保ちつつ高い凝集度を維持することができます。

### AIとツールを活用したSQL生成と最適化
直接的なSQLの扱いを可能にすることで、AIやツールを使用した自動生成や最適化が容易になります。AIを活用最適なクエリを生成したり、SQLチューニングツールでパフォーマンスを分析して自動的に改善案を提案することが可能です。これにより、パフォーマンスの向上と効率的なリソース利用が実現されます。

### 総合的なデバッグとメンテナンスの利便性
SQLの直接管理は、エラー発生時のデバッグを容易にします。SQLクエリの動作を直接観察し、問題の特定と修正を迅速に行うことができます。また、クエリの修正や機能の拡張が直接的に行えるため、アプリケーションのメンテナンスと進化がスムーズに進行します。



* PHPインターフェイスとSQLを用意して、クラスを実装することなしにPHPのインターフェイスにSQLの実行オブジェクトを束縛することができます。
* PHPのインターフェイスにはスカラー値だけでなくオブジェクトを指定して文字列として評価することもできます。例えばDateTimeInterfaceを指定すると、SQLの日付として評価されます。
* PHPインターフェイスには引数を依存性として注入することができます。

### ドキュメント生成

コードからAPIドキュメントを自動生成します。コードとドキュメントの整合性を保ち、保守性を高めます。

### 他システムとの統合

* コンソールアプリケーションと統合し、ソースコードを変えずにWebとコマンドライン双方からアクセス可能にします
* 同一PHPランタイム内で異なるアプリケーションを並行実行でき、HTTPクライアントから全リソースにアクセス可能にします。
* ローカル及びリモートのBEAR.Sundayアプリケーションを同様に扱え、BEAR.Thriftでは他言語のアプリケーションとも連携できます。

### 標準への準拠

* デフォルトでJSON形式とwwwフォーム形式をサポートし、コンテントタイプに応じてリソースリクエストを解釈します。
* セマンティックバージョンニングを採用し、後方互換性を維持します。
* エラーはデフォルトでは`vnd.error+json`メディアタイプ形式で返却され、エラーの詳細を含めたエラーメッセージを返します。
* リソースの状態変更時にETagを使用して、キャッシュを無効化します。
* キャッシュするとHTTPヘッダーに`Cache-Control`に加え`Ages`、`Last-Modified`。`ETag`などのHTTPヘッダーが付与されます

### オブジェクト指向原則

BEAR.Sundayはアプリケーションを長期的にメンテナンス可能すとするためのオブジェクト指向原則を重視しています。

#### 継承より合成

* 継承クラスを使わず、コンポジションを推奨します。設計上、実行時に唯一継承が必要な抽象クラスは`BEAR\Resource\ResourceObject`のみです。しかし継承したクラスからは親クラスのメソッドを呼び出さないことが原則で、必要なものは原則的にコンポジションで解決します。すなわちResourceObjectが保持する最小限のメソッドは継承した子クラスが呼び出すのではなく、他のクラスが利用するのが原則です。つまりフレームワークが用意したメソッドを使う場面は実質1つも存在しません。

### 全てがインジェクション

フレームワークのクラスが「設定ファイル」や「デバック定数」を実行中に参照して振る舞いを決定する事はありません。振る舞いに応じた依存が注入されます。これにより、アプリケーションの振る舞いを変更するためには、コードを変更する必要がなく、インターフェイスに対する依存性の実装の束縛を変更するだけで済みます。APP_DEBUGやAPP_MODE定数は存在しません。コンテキストによって依存が注入されたソフトウエアが起動を始め後は現在どのモードで動いているのか誰も知らないし、知る必要もありません。

### ルートオブジェクト

DIの本来の世界では、ユーザーは可能な限りインジェクター（DIコンテナ）を直接扱いません。その代わり、アプリケーションのエントリーポイントで1つのルートオブジェクトを生成してアプリケーションを起動します。BEAR.SundayのDIでは、設定時でもDIコンテナの操作が実質存在しません。ルートオブジェクトは巨大ですが1つの変数なのでリクエストを超えて再利用され極限まで最適化したブートストラップを実現します。

BEAR.Sundayは原則イミュータブルなシステムなので、テストの時も初期化を繰り返さないのでテスト実行が非常に高速です。PDOの接続はテストのリクエストを超えて再利用され枯渇することもありません。テストの時はリクエストを超えたシングルトンが実現します。

### コード品質

高いコード品質のアプリケーションを提供するためにBEAR.Sundayフレームワークも高い水準でコード品質を保っています。

* フレームワークのコードは静的解析ツールのpsalmとphpstan双方でレベル最大で適用しています。
* テストカバレッジ100%を保っています。
* タイプカバレッジもほぼ100%です。mixedの使用を最小化しています。
* 原則的にイミュータブルなシステムであり、テストでも毎回初期化が不要なほどクリーンです。SwooleのようなPHPの非同期通信エンジンの力を引き出します。
