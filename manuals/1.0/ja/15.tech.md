---
layout: docs-ja
title: 技術
category: Manual
permalink: /manuals/1.0/ja/tech.html
---
# 技術

この章では、BEAR.Sundayの機能と技術的特徴を説明します。

## 依存性の注入 (DI)

> "Objects are injected from the interface, just as sun ray is injected when a window is opened."

依存性の注入(DI)は、オブジェクトの生成や依存関係の解決をフレームワークが自動で行うことで、コードの結合度を下げ、テスト性と保守性を高めるパターンです。BEAR.SundayのDIは[Ray.Di](https://github.com/ray-di/Ray.Di)という独立したパッケージを使用しており、Google社製のDIフレームワークであるGuiceの設計思想を取り入れ、ほぼすべての機能をカバーしています。

このフレームワークのDIが他のフレームワークと異なる点は、ユーザーがコンテナに直接触れることなく、ルールに基づいて依存関係を解決するオートワイヤリングが基本となっていることです。その他の特徴は次のとおりです。

* コンテキストに応じた束縛で、アプリケーションの振る舞いをコンパイル時に変更します。
* アトリビュートによる設定でコードの自己記述性が高まります。
* 同じインターフェイスで違う実装を束縛するためのクオリファイアーを使うことでもコードの自己記述性が高まります。
* Ray.Diはコンパイル時に依存性の解決を行うため、ランタイム時のパフォーマンスが向上します。これは、実行時に依存性を解決する他のDIコンテナとは異なる点です。
* オブジェクトの依存関係をグラフで可視化できます。
* リンク束縛、インスタンス束縛などの他にもアトリビュート束縛、アンターゲット束縛、マルチ束縛、コンストラクと束縛、コンテキスト束縛、Null束縛など多様な束縛がサポートされています。
* 遅延束縛するためのプロバイダ束縛も可能です。
* 束縛はモジュールとしてまとめることができ、再利用性が高まります。

<img src="https://ray-di.github.io/images/logo.svg" width="180" alt="Ray.Di logo">

## アスペクト指向プログラミング (AOP)

> "Aspects wrap your objects, like a gift wrap enhances a present."

アスペクト指向プログラミング(AOP)は、ビジネスロジックなどの本質的な関心と、ログやキャッシュなどの横断的関心を分離することで、柔軟なアプリケーションを実現するパターンです。BEAR.SundayのAOPはRay.Aopという独立したパッケージを使用しており、PHPのアトリビュートをクラスやメソッドに付与して、横断的処理を宣言的に束縛します。

AOPは誤解の多い技術の一つです。その存在意義は制約を無視して秩序を壊すものではなく、探索的な機能の割り当てや横断的処理の分離などオブジェクト指向が不得意とする分野を補完し、アプリケーション横断的な制約を作る、つまりアプリケーションフレームワークの制約として設計が可能なパラダイムの1つです。

その他のAOPの特徴は次のとおりです。

* クラスやメソッド名などの探索条件に適合したクラスやメソッドに横断的処理を束縛できます。
* PHP のアトリビュートを使用することで、横断的処理を宣言的に記述できます。
* 探索条件に適合したクラスやメソッドを動的に変更できます。


## リソース指向のアーキテクチャ (ROA)

> "Resources interconnected, like the web of life that binds all creatures.”

BEAR.SundayのROA は、RESTful な API を Web アプリケーションの内部構造で実現するためのアーキテクチャであり、BEAR.Sundayの設計原則の中核を成すものです。これはハイパーメディア フレームワークであり、オブジェクト as a サービスでもあります。Web と同様に、すべてのデータや機能をリソースとして扱い、GET/POST/PUT/DELETE などの規定されたインターフェイスで操作します。またリソースとリソースは相互に接続されています。リソースが他のリソースへのハイパーリンクを提供することでリソースは情報や機能を提供するだけでなく、アフォーダンスも提供することができます。

### ユニフォームインターフェース

リソースへのアクセスはHTTPのメソッド（GET, POST, PUT, DELETE）を用いて行われます。これらのメソッドはリソースに対して実行できる操作を規定しており、リソースの種類に関わらず共通のインターフェースを提供します。

- GET: リソースの現在の状態を取得する
- POST: リソースに対して冪等性のない操作を行う（作成など）
- PUT: リソースに対して冪等性のある操作を行う（作成または更新など）
- DELETE: リソースを削除する

### ハイパーメディア

リソース間のリンクはハイパーメディアによって表現されます。各リソースの表現にはリンクが含まれ、クライアントはこれらのリンクをたどることでアプリケーション内を遷移できます。これによってクライアントとサーバー間の結合度が低くなり、アプリケーションの柔軟性が高まります。内部にリンクすることでコンテンツをツリー状に表すこともできます。

### 値と表現の分離

BEAR.SundayのROAでは、リソースの値と表現が明確に分離されています。リソースの値はアプリケーションのドメインロジックによって管理され、表現はその値を様々な形式（JSON, XML, HTMLなど）で表現するためのものです。この分離によってドメインロジックとプレゼンテーションロジックが疎結合になり、アプリケーションの保守性と拡張性が向上します。

### pageリソースとappリソース

BEAR.SundayのROAでは、リソースをpageリソースとappリソースに分類しています。

-pageリソース: 主にHTMLを表現とするリソースで、Webブラウザからアクセスされることを想定しています。ユーザーインターフェースを構成するリソースです。
-appリソース: アプリケーションのバックエンドを構成するリソースで、主にJSONやXMLを表現とします。他のアプリケーションやサービスからアクセスされることを想定しています。

pageリソースとappリソースを分離することで、ユーザーインターフェースとアプリケーションロジックを独立に開発・デプロイできます。また、appリソースを再利用することで、複数のユーザーインターフェース（Webブラウザ、モバイルアプリ、他のサービスなど）に対して一貫したバックエンドを提供できます。

BEAR.SundayのROAを用いることで、Webの設計原則に沿ったスケーラブルで疎結合なアプリケーションを構築できます。値と表現の分離によってドメインロジックとプレゼンテーションロジックを独立に開発・テストできるため、アプリケーションの品質と開発効率が向上します。またpageリソースとappリソースを分離することで、ユーザーインターフェースとアプリケーションロジックを独立に開発・デプロイでき、アプリケーションの柔軟性と拡張性が向上します。またハイパーリンクはリソース間の関係性を明示し、クライアントとサーバー間の結合度を低く保ちリソースの自己記述性やAPIの発見性を高めます。

### MVCとの相違点

BEAR.SundayのROAは、従来のMVCアーキテクチャとは異なるアプローチをとっています。

* MVCのコントローラーは複数の責任を持ちがちですが、BEAR.SundayのリソースはDIとAOPで単一責任の原則（SRP）に従い、責任が分散されています。
* MVCのコントローラーは様々な操作を行いますが、BEAR.Sundayのリソースはセマンティックなメソッド（意味的に明確なメソッド）を持ち、操作が明確になります。
* BEAR.Sundayでは埋め込みリソースを使い、コンテンツの内包関係が宣言的に示されます。これによりリソース間の関係性が明示的になるだけでなく、キャッシュ無効化のための依存解決も行えます。
* BEAR.Sundayはリソース自身が表現の責任を持ち、自己完結性が高まります。
* BEAR.Sundayのリソースはリレーションを宣言することで、可能な操作（アフォーダンス）を提供します。クライアントはこれを手がかりにリソースを動的に操作できます。自己記述的です。
  リンクにはHAL（Hypertext Application Language）を採用し、リソース間のリンクを標準化します。
* MVCのモデルと違って、コンソールを含む多様なクライアントから直接コールすることができます。
* HTMLサイトとAPIサイトを別々に構築する必要がなく、同じリソースを使ってHTMLサイトとAPIサイトを同時に構築できます。

## モダンCDNとの統合によるROAベースのイベントドリブンコンテンツ戦略

> "No volatility, just what users truly desire."

BEAR.Sundayは、リソース指向アーキテクチャ（ROA）を中核として、Fastlyなどのインスタントパージ可能なCDNと統合することで、高度なイベントドリブンキャッシュ戦略を実現しています。この戦略では、従来のTTL（Time to Live）によるキャッシュの無効化ではなく、リソースの状態変更イベントに応じてCDNとサーバーサイドのキャッシュ、およびETag（Entity Tag）を即座に無効化します。

揮発性を排除したこのアプローチは、SPOF（Single Point of Failure）を回避し、高い可用性と耐障害性を実現するだけでなく、ユーザー体験とコスト効率を最大化させ、ダイナミックコンテンツでもスタティックコンテンツと同じWeb本来の分散キャッシングを実現します。つまり、Webが1990年代から持っていたスケーラブルでネットワークコストも削減する分散キャッシュという原則を、現代的な技術で再実現しているのです。

### セマンティックメソッドによるキャッシュ無効化
BEAR.SundayのROAでは、各リソース操作にセマンティック（意味的な役割）が与えられています。例えば、GET メソッドはリソースを取得し、PUT メソッドはリソースを更新します。これらのメソッドがイベントドリブン方式で連携し、関連するキャッシュを効率的に無効化します。たとえば、特定のリソースが更新された際には、その変更が依存する他のリソースに自動的に伝播し、関連するキャッシュが無効化されます。これにより、データの一貫性と新鮮さが保たれ、ユーザーに最新の情報が提供されます。

### 埋め込みリンクによる依存関係の可視化
ROAの設計では、リソースは他のリソースへのリンクを含むことができ、これによりリソース間の依存関係がクライアントに透明に示されます。このリンク情報を活用することで、キャッシュの無効化が必要な場合にどのリソースが影響を受けるかを瞬時に判断でき、効率的なキャッシュ管理が可能になります。

### 引数の宣言によるキャッシュキー生成
BEAR.Sundayでは、リソースメソッドの引数が明確に宣言されています。これにより、リソースの状態やリクエストパラメータに基づいて独自のキャッシュキーを生成することができます。キャッシュキーの生成は、リソースの状態が変更されたときに特定のキャッシュを正確に特定し、無効化するための重要なメカニズムです。これにより、不必要なキャッシュの削除を避けつつ、必要な部分だけを迅速に更新することができます。

### ETagによる同一性確認と迅速な応答
システムがブートする前にETagを設定することで、コンテンツの同一性を迅速に確認し、変更がなければ304 Not Modified応答を返します。これはネットワークの負荷を減少させ、ユーザーエクスペリエンスを向上させるための効果的な手法です。

### ドーナッツキャッシュとESIによる部分的な更新
BEAR.Sundayでは、ドーナッツキャッシュ戦略を採用しており、Edge Side Includes (ESI)を使用してCDNエッジで部分的なコンテンツ更新を可能にしています。この技術により、ページ全体を再キャッシュすることなく、必要な部分だけを動的に更新でき、パフォーマンスとキャッシュの効率を大幅に向上させています。

このように、BEAR.SundayとFastlyの統合によるROAベースのキャッシュ戦略は、高度な分散キャッシングの実現とともに、アプリケーションのパフォーマンス向上と耐障害性の強化を実現しています。これにより、ユーザーはどんな状況下でも一貫した応答性とデータ整合性を体験することができます。

## テストの容易性

* 各リソースは独立していて、RESTのステートレスリクエストの性質によりテストは容易です。
* リソースの状態と表現を分離されているので、リソースの状態のみをテスト可能です。
* ハイパーメディアのリンクをたどりながらAPIのテストを行え、PHPとHTTPの同一コードでテストできます。

## リソースの検証

JsonSchemaを使用してリソースの表現を検証し、リソースの整合性を保ちます。バリデーションに標準のスキーマを使うことで外部ツールの利用ができます。

## ストリーム出力
* リソースの表現をストリーム出力することで、メモリ上では扱えない大規模なコンテンツを出力できます。
* ストリームは通常の値のアサインと混在することができます。

## 視覚化とデバッグ

* 開発時にHTML上でリソースの範囲やツールをグラフィカルに表示します。
* Web画面でリソースの状態を確認でき、PHPコードやHTMLテンプレートをオンラインで編集し、リアルタイムに反映できます。

## 起動の高速化

* 事前コンパイルにより依存生成のPHPコードを生成して最小限のブートストラップを実現します。
* 理想的なDIの世界では起動の時に1度だけインスタンスを生成します。これをルートオブジェクトと呼びますがこのルートオブジェクトをキャッシュすることで、初期化を再利用しアプリケーションの起動を高速化します。

## PHPインターフェイスとSQL実行の統合
BEAR.Sundayでは、PHPのインターフェイスを使って、データベースとのやり取りを行うSQL文の実行を簡単に管理できます。クラスを実装することなく、インターフェイスに直接SQLの実行オブジェクトを束縛することが可能です。これにより、コードの再利用性が向上し、モジュール性が強化されます。

### クエリー引数の評価
BEAR.Sundayのインターフェイスは、単なるスカラー値だけでなくオブジェクトも受け入れることができます。特に、オブジェクトがインターフェイスによってどのように評価されるかは重要です。例えば、DateTimeInterface オブジェクトをインターフェイスに渡すと、これがSQL文内で適切に日付として扱われるように自動的に評価されます。これにより、日付や時刻のデータを効率的に扱うことができます。

### クエリーの引数の依存性注入
BEAR.Sundayでは、インターフェイスに対して依存性を注入することも可能です。これにより、必要なオブジェクトや値を動的にインターフェイスに供給することができ、より柔軟なアプリケーション設計が実現されます。依存性注入を用いることで、コードのテストが容易になり、結合度を低く保ちつつ高い凝集度を維持することができます。

### AIとツールを活用したSQL生成と最適化
BEAR.Sundayでは、インターフェイスに対して依存性を注入することも可能です。これにより、必要なオブジェクトや値を動的にインターフェイスに供給することができ、より柔軟なアプリケーション設計が実現されます。依存性注入を用いることで、コードのテストが容易になり、結合度を低く保ちつつ高い凝集度を維持することができます。

### 総合的なデバッグとメンテナンスの利便性
SQLの直接管理は、エラー発生時のデバッグを容易にします。SQLクエリの動作を直接観察し、問題の特定と修正を迅速に行うことができます。また、クエリの修正や機能の拡張が直接的に行えるため、アプリケーションのメンテナンスと進化がスムーズに進行します。

* PHPインターフェイスとSQLを用意して、クラスを実装することなしにPHPのインターフェイスにSQLの実行オブジェクトを束縛することができます。
* PHPのインターフェイスにはスカラー値だけでなくオブジェクトを指定して文字列として評価することもできます。例えばDateTimeInterfaceを指定すると、SQLの日付として評価されます。
* PHPインターフェイスには引数を依存性として注入することができます。

## APIドキュメント生成

コードからAPIドキュメントを自動生成します。コードとドキュメントの整合性を保ち、保守性を高めます。

## 他システムとの統合

* コンソールアプリケーションと統合し、ソースコードを変えずにWebとコマンドライン双方からアクセス可能にします
* 同一PHPランタイム内で異なるアプリケーションを並行実行でき、HTTPクライアントから全リソースにアクセス可能にします。
* ローカル及びリモートのBEAR.Sundayアプリケーションを同様に扱え、BEAR.Thriftでは他言語のアプリケーションとも連携できます。

## 標準への準拠

* デフォルトでJSON形式とwwwフォーム形式をサポートし、コンテントタイプに応じてリソースリクエストを解釈します。
* セマンティックバージョンニングを採用し、後方互換性を維持します。
* エラーはデフォルトでは`vnd.error+json`メディアタイプ形式で返却され、エラーの詳細を含めたエラーメッセージを返します。
* リソースの状態変更時にETagを使用して、キャッシュを無効化します。
* キャッシュするとHTTPヘッダーに`Cache-Control`に加え`Ages`、`Last-Modified`。`ETag`などのHTTPヘッダーが付与されます

## オブジェクト指向原則

BEAR.Sundayはアプリケーションを長期的にメンテナンス可能すとするためのオブジェクト指向原則を重視しています。

### 継承より合成

継承クラスよりコンポジションを推奨します。一般に子クラスから親クラスのメソッドを直接呼び出すことは、クラス間の結合度を高くする可能性があります。設計上ランタイムで継承が必要な抽象クラスはリソースクラスの`BEAR\Resource\ResourceObject`のみですが、これもResourceObjectのメソッドは他のクラスが利用するためだけに存在します。ユーザーが継承したフレームワークの親クラスのメソッドをランタイムに呼び出すことはBEAR.Sundayではどのクラスにもありません。

### 全てがインジェクション

フレームワークのクラスが「設定ファイル」や「デバック定数」を実行中に参照して振る舞いを決定する事はありません。振る舞いに応じた依存が注入されます。これにより、アプリケーションの振る舞いを変更するためには、コードを変更する必要がなく、インターフェイスに対する依存性の実装の束縛を変更するだけで済みます。APP_DEBUGやAPP_MODE定数は存在しません。ソフトウエアが起動した後に現在どのモードで動いているか知る方法はありませんし、知る必要もありません。

### ルートオブジェクト

DIの本来の世界では、ユーザーは可能な限りインジェクター（DIコンテナ）を直接扱いません。その代わり、アプリケーションのエントリーポイントで1つのルートオブジェクトを生成してアプリケーションを起動します。BEAR.SundayのDIでは、設定時でもDIコンテナの操作が実質存在しません。ルートオブジェクトは巨大ですが1つの変数なのでリクエストを超えて再利用され極限まで最適化したブートストラップを実現します。

## 後方互換性の非破壊

BEAR.Sunday は、ソフトウェアの進化において後方互換性の維持を重視して設計されています。現代のソフトウェア開発では、頻繁な後方互換性の破壊と、それに伴う改修やテストの負担が課題となっていますが、BEAR.Sunday はこの問題を避けることを目指し成功しています。

これは、ソフトウェアの進化を止めるということではありません。Webは数十年にわたって変化し続けていますが、その核心部分は変わらず、後方互換性が保たれてきました。BEAR.Sunday は、このWebの精神をアプリケーションフレームワークにも適用しようと設計されました。

BEAR.Sunday では、セマンティックバージョニングを採用し、新しい機能の追加や既存機能の変更が既存のコードに影響を与えることを防いでいます。古くなって使われなくなったコードは「deprecated」の属性が与えられますが、削除されることはなく、既存のコードの動作にも影響を与えません。代わりに、新しい機能が追加され、進化が続けられます。

実際、BEAR.SundayはPHP5.4の時のリリース以来多くの機能が追加されてきましたが、既存のアプリケーションは変更することなく動作し続けています。さらに、PHP エコシステムの進化に伴った静的解析ツールなどの活用により、コードはよりクリーンで高速なものになっています。

後方互換性の維持を絶対命題とした設計と、セマンティックバージョニングによるアプローチが、この長期的な互換性の維持を可能にしています。これにより、開発者は安心して BEAR.Sunday を採用し、進化するエコシステムの恩恵を受けることができるのです。

## コード品質

高いコード品質のアプリケーションを提供するためにBEAR.Sundayフレームワークも高い水準でコード品質を保っています。

* フレームワークのコードは静的解析ツールのpsalmとphpstan双方でレベル最大で適用しています。
* テストカバレッジ100%を保っています。
* タイプカバレッジもほぼ100%です。mixedの使用を最小化しています。
* 原則的にイミュータブルなシステムであり、テストでも毎回初期化が不要なほどクリーンです。SwooleのようなPHPの非同期通信エンジンの力を引き出します。

