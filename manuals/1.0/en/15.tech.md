---
layout: docs-en
title: Technology
category: Manual
permalink: /manuals/1.0/en/tech.html
---
# Technology

This chapter explains the unique features and technologies of BEAR.Sunday.

## Architecture and Design Principles

### Resource-Oriented Architecture (ROA)

BEAR.Sunday's ROA is an architecture for implementing RESTful APIs within web applications. It is the core of BEAR.Sunday's design principles, serving as both a hypermedia framework and a way to treat "objects as services." Like the Web, all data and functions are considered resources and are manipulated through standardized interfaces such as GET, POST, PUT, DELETE, etc.

#### URI

URI (Uniform Resource Identifier) is a key element to the success of the Web and is also at the core of BEAR.Sunday's ROA. By assigning URIs to all resources handled by the application, resources can be identified and easily accessed. URIs not only function as identifiers for resources but are also used to express relationships between resources.

#### Uniform Interface

Access to resources is done using HTTP methods (GET, POST, PUT, DELETE). These methods specify the operations that can be performed on a resource and provide a common interface regardless of the type of resource.

#### Hypermedia

In BEAR.Sunday's ROA, each resource provides affordances (operations and functions available to the client) through hyperlinks. These links represent the operations available to the client and provide instructions on how to navigate within the application.

#### Separation of Value and Representation

In BEAR.Sunday's ROA, a resource's value and representation are clearly separated. Resource values are managed by the application's domain logic, while representations are for expressing those values in various formats (JSON, XML, HTML, etc.). This separation results in loose coupling between domain logic and presentation logic.

#### Differences from MVC

BEAR.Sunday's ROA takes a different approach from the traditional MVC architecture. MVC composes an application with three components: Model, View, and Controller. In contrast, BEAR.Sunday injects views into resource objects. Resources and views are loosely coupled, with their responsibilities clearly separated.

Also, in contrast to the lack of constraints on the relationship between controllers and models, resources have constraints on including other resources using hyperlinks and URIs, and this can be done declaratively.

Unlike MVC models, resources can be directly called from diverse clients including the console, and there are differences such as being able to simultaneously build HTML sites and API sites using the same resources without needing to construct HTML sites and API sites separately.

### Dependency Injection (DI)

Dependency Injection (DI) is an important technique for enhancing the design and structure of applications in object-oriented programming. The central purpose of DI is to divide an application's functionality into multiple components with independent domains or roles and manage the dependencies between them.

DI helps horizontally split a single function into multiple functions. The split functions can be independently developed and tested as "dependencies." Based on the single responsibility principle, by injecting those dependencies with clear responsibilities and roles from the outside, it improves object reusability and testability. Dependencies are also vertically split into other dependencies, forming a tree of dependencies.

BEAR.Sunday's DI uses a separate package called [Ray.Di](https://github.com/ray-di/Ray.Di), which incorporates the design philosophy of Google's DI framework Guice and covers almost all of its features.

Other features include:

* Bindings can be changed based on context, allowing different implementations to be injected during testing.
* Configuration via attributes increases code self-descriptiveness.
* Ray.Di resolves dependencies at compile-time, improving runtime performance. This differs from other DI containers that resolve dependencies at runtime.
* Object dependencies can be visualized as a graph. Example: [Application Skeleton](/images/app.svg)

<img src="https://ray-di.github.io/images/logo.svg" width="180" alt="Ray.Di logo">

### Aspect-Oriented Programming (AOP)

Aspect-Oriented Programming (AOP) is a pattern that enables flexible applications by separating core concerns such as business logic from cross-cutting concerns such as logging and caching. Cross-cutting concerns refer to functions or processes that span multiple modules or layers. Binding of cross-cutting processes based on search conditions is possible, allowing for flexible configurations based on context.

BEAR.Sunday's AOP uses a separate package called Ray.Aop, which declaratively binds cross-cutting processes by attaching PHP attributes to classes or methods. Ray.Aop adheres to Java's [AOP Alliance](https://aopalliance.sourceforge.net/) and has the following characteristics.

AOP is one of the most misunderstood technologies. Its purpose is never to break order for the sake of powerful capabilities, but rather to complement areas where object-orientation struggles, such as the exploratory assignment of functionality using matchers and the separation of cross-cutting processes. AOP is a paradigm that functions as an application framework by creating cross-cutting constraints for applications.

## Performance and Scalability

### ROA-based Event-Driven Content Strategy with Modern CDN Integration

BEAR.Sunday achieves an advanced event-driven caching strategy by integrating with instant-purgeable CDNs like Fastly, with its Resource-Oriented Architecture (ROA) at the core. Instead of traditional cache invalidation based on Time to Live (TTL), this strategy immediately invalidates the CDN, server-side cache, and ETag (Entity Tag) based on resource state change events.

This approach, which eliminates volatility, not only avoids Single Point of Failure (SPOF) and achieves high availability and fault tolerance but also maximizes user experience and cost efficiency, realizing the Web's original distributed caching for dynamic content just like static content. It re-implements the scalable and network cost-reducing distributed caching principles that the Web has had since the 1990s using modern technologies.

#### Cache Invalidation through Semantic Methods and Dependencies

In BEAR.Sunday's ROA, each resource operation is given a semantic (meaningful role). For example, the GET method retrieves a resource, while the PUT method updates a resource. These methods work together in an event-driven manner to efficiently invalidate related caches. For instance, when a specific resource is updated, the cache of resources that require that resource is invalidated. This ensures data consistency and freshness, providing users with the latest information.

#### Rapid Response with ETag for Identity Verification

By setting the ETag before the system boots, content identity can be quickly verified, and if there are no changes, a 304 Not Modified response is returned to minimize network load.

#### Partial Updates with Donut Caching and ESI

BEAR.Sunday adopts the donut caching strategy and uses ESI (Edge Side Includes) to enable partial content updates at the CDN edge. This technology allows dynamic updates of only the necessary parts without re-caching the entire page, improving caching efficiency.

In this way, BEAR.Sunday's ROA-based caching strategy integrated with Fastly not only achieves advanced distributed caching but also improves application performance and enhances fault tolerance.

### Faster Startup

In the original world of DI, users avoid dealing with the injector (DI container) directly as much as possible. Instead, the application is started by creating a single root object at the application's entry point. In BEAR.Sunday's DI, there is essentially no DI container manipulation even during configuration. The root object is huge but is a single variable, so it is reused across requests to realize a highly optimized bootstrap.

## Developer Experience

### Ease of Testing

BEAR.Sunday allows for easy and effective testing due to the following design characteristics:

- Each resource is independent, and the stateless request nature of REST makes testing straightforward.
- Since resource state and representation are separated, it is possible to test the resource state even when using HTML representation.
- API testing can be performed by following hypermedia links, using the same PHP and HTTP code for testing.
- Different implementations can be bound for testing through context-dependent binding.

### API Documentation Generation

API documentation is automatically generated from code, maintaining consistency between code and documentation and improving maintainability.

### Visualization and Debugging

By leveraging the technical feature of resources rendering themselves, during development, the scope of resources can be indicated on HTML, resource states can be monitored, and PHP code and HTML templates can be edited in an online editor and reflected in real-time.

## Extensibility and Integration

### Integration of PHP Interfaces and SQL Execution

In BEAR.Sunday, SQL statements for interacting with databases can be easily managed using PHP interfaces. SQL execution objects can be directly bound to PHP interfaces without implementing classes. The boundary between the domain and infrastructure is connected by PHP interfaces.

Arguments can also be typed, and any missing arguments are resolved by DI and used as strings. Even when the SQL execution requires the current time, there is no need to pass it explicitly; it is automatically bound. This helps keep the code concise as the client is not responsible for passing all arguments.

Direct management of SQL also facilitates debugging when errors occur. The behavior of SQL queries can be directly observed, allowing for quick identification and correction of issues.

### Integration with Other Systems

Integration with console applications allows access from both the Web and command line without changing the source code. Also, by enabling the concurrent execution of different BEAR.Sunday applications within the same PHP runtime, multiple independent applications can be coordinated without building microservices.

### Stream Output

By assigning streams like file pointers to the body of a resource, large-scale content that cannot be handled in memory can be output. Streams can also be mixed with regular variables, allowing flexible output of large responses.

### Gradual Migration from Other Systems

BEAR.Sunday provides a gradual migration path, enabling seamless integration with other frameworks and systems such as Laravel and Symfony. Since this framework can be implemented as a Composer package, developers can gradually introduce BEAR.Sunday's features into their existing codebase.

### Flexibility of Technology Migration

BEAR.Sunday protects investments by preparing for future technological changes and evolving requirements. Even if there is a need to migrate from this framework to another framework or language, the resources built will not be wasted. In the PHP environment, BEAR.Sunday applications can be integrated as Composer packages and continuously utilized, and BEAR.Thrift allows efficient access to BEAR.Sunday resources from other languages. Even when not using Thrift, access via HTTP is possible. Reuse of SQL code is also easy.

If the dependent libraries strongly depend on a specific PHP version or library, making it difficult to upgrade to the latest PHP version, BEAR.Thrift can be used to coexist with different PHP versions.

## Design Philosophy and Quality

### Adoption of Standard Technologies and Elimination of Framework-Specific Standards

BEAR.Sunday follows a design philosophy of adopting standard technologies wherever possible and eliminating framework-specific standards and rules. For example, it supports content negotiation for JSON format and www-form format HTTP requests by default and uses the [vnd.error+json](https://github.com/blongden/vnd.error) media type format for error responses. It actively incorporates standard technologies and specifications, such as using [HAL](https://datatracker.ietf.org/doc/html/draft-kelly-json-hal) (Hypertext Application Language) for links between resources and [JsonSchema](https://json-schema.org/) for validation.

On the other hand, it eliminates framework-specific validation rules and standards as much as possible.

### Object-Oriented Principles

BEAR.Sunday emphasizes object-oriented principles to make applications maintainable in the long term.

#### Composition over Inheritance

Composition is recommended over inheritance classes. In general, directly calling parent class methods from child classes can potentially increase coupling between classes. There is only one abstract class that requires inheritance at runtime by design, which is `BEAR\Resource\ResourceObject` in the resource class, but its methods only exist for other classes to use. There are no classes in BEAR.Sunday where the user calls methods of an inherited framework parent class at runtime.

#### Everything is Injected

Framework classes do not refer to "configuration files" or "debug constants" at runtime to determine their behavior. Dependencies corresponding to the behavior are injected. This means that to change the application's behavior, there is no need to change the code; only the binding of the implementation of the dependency to the interface needs to be changed. There are no APP_DEBUG or APP_MODE constants. There is no way to know the current mode the software is running in after it has started, and there is no need to know.

### Permanent Backward Compatibility

BEAR.Sunday is designed with a focus on maintaining backward compatibility in the evolution of software. In modern software development, frequent breaking of backward compatibility and the associated burden of modifications and testing have become a challenge, but BEAR.Sunday aims to avoid this problem and has been successful.

BEAR.Sunday not only adopts semantic versioning but also does not perform major version upgrades that involve breaking changes. It prevents the addition of new features or changes to existing features from impacting existing code. Deprecated code is given a "deprecated" attribute but is never removed, and it does not affect the operation of existing code. Instead, new features are added, and evolution continues.

### Code Quality

To provide applications with high code quality, the BEAR.Sunday framework itself maintains a high standard of code quality.

* The framework code applies the most stringent levels of both psalm and phpstan static analysis tools.
* It maintains 100% test coverage, and type coverage is also nearly 100%.
* It is fundamentally an immutable system and is so clean that reinitialization is unnecessary even in tests. It brings out the power of PHP's asynchronous communication engines like Swoole.

## Value Brought by BEAR.Sunday

### Value for Developers

- Increased productivity: Based on robust design patterns and principles with constraints that do not change over time, developers can focus on core business logic.
- Team collaboration: By providing development teams with consistent guidelines and structure, it keeps the code of different engineers loosely coupled yet unified, improving code readability and maintainability.
- Flexibility and extensibility: BEAR.Sunday's policy of not including libraries gives developers flexibility and freedom in component selection.
- Ease of testing: BEAR.Sunday's DI (Dependency Injection) and ROA (Resource-Oriented Architecture) enhance testability.

### Value for Users

- High performance: BEAR.Sunday's optimized fast startup and CDN (Content Delivery Network)-centric caching strategy bring users a fast and responsive experience.
- Reliability and availability: BEAR.Sunday's CDN-centric caching strategy minimizes single points of failure (SPOF), allowing users to enjoy stable services.
- Ease of use: BEAR.Sunday's excellent connectivity makes it easy to collaborate with other languages and systems.

### Value for Businesses

- Reduced development costs: The consistent guidelines and structure provided by BEAR.Sunday promote a sustainable and efficient development process, reducing development costs.
- Reduced maintenance costs: BEAR.Sunday's approach to maintaining backward compatibility increases technological continuity and minimizes the time and cost of change response.
- High scalability: With technologies like DI (Dependency Injection) and AOP (Aspect-Oriented Programming), BEAR.Sunday allows applications to be easily expanded in line with business growth and changes while minimizing code changes.
- Excellent User Experience (UX): By providing high performance and high availability, BEAR.Sunday enhances user satisfaction, increases customer loyalty, expands the customer base, and contributes to business success.

Great constraints do not change. The constraints brought by BEAR.Sunday provide specific value to developers, users, and businesses respectively.

BEAR.Sunday is a framework designed based on the principles and spirit of the Web, empowering developers to build flexible and robust applications by providing excellent constraints.
